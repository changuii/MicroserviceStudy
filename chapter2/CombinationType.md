# 2.3 결합 유형

앞서 설명한 개요에 따르면 모든 결합이 나쁘다고 생각할 수 있다.  
엄밀히 말해 이것은 사실이 아니다.  
궁극적으로 시스템에서 일부 결합은 피할 수 없으며, 우리는 결합의 양을 줄이길 원한다.  

주로 모듈식(비분산, 모놀리식) 소프트웨어를 고려하는 구조적 프로그래밍 맥략에서 다양한 결합 형태를 살펴보고자 많은 연구가 수행돼 왔다.  
결합의 중첩 및 충돌을 평가하는 다양한 모델 중 상당수는 서비스 기반 상호작용보다는 코드 수준에서 주로 이야기된다.  

마이크로서비스는 모듈식 아키텍처의 한 형태이므로, 이러한 원시 개념을 많이 사용할 수 있고 마이크로서비스 기반 시스템 관점에도 적용할 수 있다.  

모든 개념이 깔끔하게 매핑되지는 않으므로 이 책에서는 마이크로서비스의 다양한 결합 유형에 대한 동작 모델을 종합하려고 최선을 다했다.  
개념이 기존 정의와 명확하게 일치하는 곳에서는 그 용어를 고수해왔고, 다른 곳에서는 새로운 용어를 고안하거나 다른 분야에서 유래한 개념과 혼합해야 했다.  

따라서 이 분야의 많은 선행 기술 위에 무엇이 만들어지는 지를 고려하라.  

| 도메인                        | 통과 | 공통 | 내용 |
| ----------------------------- | ---- | ---- | ---- |
| 느슨한 결합(낮은 수준의 결합) |      |      | 강한 결합(높은 수준의 결합) |

각 형태의 결합을 차례로 검토하고 이러한 형태가 마이크로서비스 아키텍처에서 어떻게 발현되는지 보여주는 예를 살펴본다.  

## 2.3.1 도메인 결합  

도메인 결합은 첫 번째 마이크로서비스가 다른 마이크로서비스가 제공하는 기능을 사용해야 하므로 하나의 마이크로서비스가 다른 마이크로서비스와 상호작용해야 하는 상황을 설명한다.  
  

뮤직코프 내부에서 CD 주문이 관리되는 일부 방식을 보여준다.  
이 예에서 주문처리기는 창고 마이크로서비스를 호출해 재고를 예약하고, 결졔 마이크로서비스를 호출해 결제한다.  
따라서 주문 처리기는 이 자업을 위해 창고 및 결제 마이크로서비스에 의존하고 결합된다.  
하지만 창고 서비스와 결제 서비스 사이에는 상호작용이 없으므로 결합도 없다.  

마이크로서비스 아키텍처에서 이 유형의 상호작용은 대개 불가피하다.  
마이크로서비스 기반 시스템은 작업을 수행하기 위해 협력하는 여러 마이크로서비스에 의존하지만, 우리는 이것을 최소한으로 유지하길 원한다.  
이러한 방식으로 하나의 서비스가 여러 하위 서비스에 의존하는 것을 볼 때 마다 한 마이크로서비스가 너무 많은 작업을 수행할 수 있기 때문에 문제가될 여지가 있다.  

일반적으로 도메인 결합은 느슨한 형태의 결합으로 간주되지만, 문제가 될 부분은 있다.  
많은 하위 마이크로서비스와 통신해야 하는 마이크로서비스는 너무 많은 로직이 집중되는 상황을 만든다.  
도메인 결합은 서비스 간에 더 복잡한 데이터 집합이 전송됨에 따라 문제가 될 수 있다.  
곧 살펴보겠지만, 종종 이와 같은 현상은 문제가 더 많은 결합 형태로 이어진다.  

정보 은닉의 중요성을 명심해라.  
꼭 필요한 것만 공유하고 필요한 최소한의 데이터만 전송해야 한다.  

## 2.3.2 통과 결합

통과 결합은 데이터가 다른 하위 마이크로서비스에 필요하다는 이유만으로 한 마이크로서비스가 다른 마이크로서비스에 데이터를 전달하는 상황을 말한다.  
여러 면에서 이 상황은 결합을 구현하는 데 가장 많은 문제를 유발하는 형태 중 하나이다.  
호출자가 호출 중인 마이크로서비스가 다른 마이크로서비스를 호출한다는 것을 알고 있을 뿐 아니라 잠재적으로 한 단계 떨어진 그 마이크로서비스까지 어떻게 동작하는지 알아야 한다는 점을 의미하기 때문이다.  

통과 결합의 한 예로 뮤직코프의 주문 처리 방식을 좀 더 자세히 살펴보겠습니다.  
주문 처리기는 주문 발송을 준비하기 위해 창고 서비스에 요청을 보낸다.  
요청 페이로드에 배송 목록을 포함해 전송하며, 이 배송 목록에는 고객의 주소뿐 아니라 배송 유형도 포함돼 있다.  
창고 서비스는 이 목록을 하위 배송 마이크로서비스에 전달한다.  

하위에서 데이터를 변경하면 상위에서 더 큰 변경을 일으킬 수 있다는 것은 통과 결합의 주요한 문제점이다.  
즉, 이 예에서는 배송 서비스에서 데이터의 포맷과 내용을 변경해야 할 경우 창고 서비스와 주문 처리기를 모두 변경해야 할 수 있다.  

이 문제를 해결할 몇 가지 방법이 있다.  
첫 번째는 호출하는 마이크로서비스가 중간자를 우회하는 시도가 합당한지 고려하는 것이다.  
앞에서 말했던 것과 달리 주문 처리기가 배송 서비스와 직접 통신한다.  
하지만 이렇게 하면 다른 골칫거리가 생긴다.  
주문 처리기가 알아야 할 또 다른 마이크로서비스로 배송 서비스가 추가되므로 도메인 결합을 늘리게 된다.  

이것이 유일한 문제점이라면 도메인 결합은 느슨한 형태의 결합이므로 괜찮은 대안이 될 수 있다.  
하지만 이 해결책은 배송 서비스를 사용해 패키지를 발송하기 전에 창고 서비스에 재고를 예약하고 배송이 완료된 후 그에 따라 재고를 업데이트 해야 하므로 더 복잡해진다.  
따라서 이전에는 창고 서비스 내부에 숨어 있던 복잡성과 로직을 주문 처리기에 밀어 넣게 된다.  

이 특정한 예에서는 주문 처리기에서 배송 목록에 대한 요구사항을 완전히 숨기는 것과 같이 보다 간단한 변경을 고려할 수 있다.  
재고 관리 작업과 패키지 발송 준비 작업을 모두 창고 서비스로 위임하려는 의도는 이해되지만, 일부 하위 수준의 구현이 누출됐다는 사실, 즉 배송 마이크로서비스가 배송 목록을 원한다는 사실은 내키지가 않는다.  

이러한 세부 사항을 숨기는 한 가지 방법은 창고 서비스가 계약의 일부로 필요한 정보를 받은 다음 로컬에서 배송 목록을 만들도록 하는 것이다.  
이렇게 하면, 배송 서비스가 서비스 계약을 변경하는 경우에도 창고 서비스가 필요한 데이터를 수집하는 동안에는 주문 처리기에서 이 변경사항이 보이지 않는다.  

이렇게 하면 배송에 대한 변경으로부터 주문 처리기 마이크로서비스를 보호하는 데 도움이 되지만, 여전히 서비스를 모두 변경할 수 밖에 없는 몇몇 경우가 있다.  
국제 배송을 시작한다고 가정해보자.  

이를 위해 배송 서비스에는 배송 목록에 포함할 세관 신고가 필요하다.  
이 정보가 필수 매개변수가 아니라면 배송 마이크로서비스의 새 버전을 문제없이 배포할 수 있다.  
하지만 필수 매개변수라면 창고 서비스에서 매개변수를 생성해야 한다.  
갖고 있는 기존 정보로 이 작업을 수행하거나 주문 처리기가 추가 정보를 전달해야할 수도 있다.  

이 경우에도 세 가지 마이크로서비스 모두에서 여전히 변경을 해야 하지만, 이러한 변경이 가능한 시기와 방법에 대해서는 훨씬 더 많은 권한이 부여됐다.  
초기 예에서 강한 통과결합이 있었다면, 새로운 세관 신고를 추가하기 위해 세 마이크로서비스를 동시에 맞춰 롤아웃 해야 할 수 있다.  

하지만 세부사항을 숨길 수 있다면 적어도 훨씬 더 쉬운 배포 단계를 진행할 수 있다.  

통과 결합을 줄이는 데 유용한 마지막 방법은 주문 처리기가 여전히 창고를 통해 배송마이크로서비스로 배송 목록을 보내지만 창고가 배송 목록 자체의 구조를 전혀 알지 못하게 하는 것이다.  

주문 처리기는 주문 요청의 일부로 배송 목록을 보내더라도 창고 서비스가 그 필드를 보거나 처리하지 못하게 한다. (데이터 덩어리로만 취급하고 내용은 전혀 신경쓰지 않으며, 단지 전달만 한다. )  
배송 목록의 형식을 변경하려면 주문 프로세스와 배송 마이크로서비스를 모두 변경해야 하지만, 창고 서비스는 실제로 그 목록의 내용물에는 관심이 없기 때문에 변경할 필요가 없다.  


## 2.3.3 공통 결합  

공통 결합은 둘 이상의 마이크로서비스가 공통 데이터 집합을 사용할 때 발생한다.  
이러한 결합 형태의 단순하고 일반적인 예는 동일한 공유 데이터베이스를 여러 마이크로서비스가 사용하는 경우지만, 공유 메모리나 공유 파일 시스템을 사용하는 경우도 해당될 수 있다.   

공통 결합의 주요 문제점은 데이터 구조를 변경하면 한 번에 여러 마이크로서비스에 영향을 미친다는 것이다.  
일부 뮤직 코프 서비스의 예를 생각해보자.  

앞서 설명한 것처럼 뮤직 코프는 전 세계에서 사업을 운영하고 있으므로 사업을 영위하는 국가에대한 다양한 정보가 필요하다.  
이 예에서는 여러 서비스가 모두 공유된 데이터베이스에서 정적 참조 데이터를 읽고 있다.  

따라서 이 데이터베이스의 스키마가 하위 호환되지 않는 방식으로 변경되면 데이터베이스의 모든 소비자를 변경해야 한다.  
실제로 이와 같은 공유 데이터는 결과적으로 변경하기가 매우 어려운 편이다.  

정적 참조 데이터의 특성상 거의 변경되지 않는 경향이 있고 읽기 전용이므로 비교적 양호하다고 할 수 있다.  
하지만 공통 데이터의 구조가 더 자주 변경되거나 여러 마이크로서비스가 동일한 데이터를 읽고 쓰는 경우라면 공통 결합은 문제가된다.  

뮤직코프 고객에게 CD를 발송하는 프로세스를 관리하려고 주문 처리기와 창고 서비스가 공유된 주문 테이블에서 읽고 쓰는 상황을 보여준다.  
두 마이크로서비스 모두 상태 커럼을 업데이트 하고 있다.  
주문 처리기는 주문 접속 (PLACED), 지불 완료 (PAID), 주문 완료(COMPLETED) 상태를 설정할 수 있고 창고 서비스는 집품(PICKING) 또는 발송완료 (SHIPPED) 상태를 적용할 수 있다.  

개념적으로는 주문 처리기와 창고 마이크로서비스가 주문 수명주기의 여러 측면을 관리한다고 생각해보자.  
주문 처리기에서 변경할 때는 창고의 호환성을 깨뜨리는 방식으로 주문 데이터를 변경하고 있지 않다고 확신할 수 있을까? 그 반대의 경우는 어떨까?  

93p

이 상황에서 잠재적인 해결책은 하나의 마이크로서비스가 주문 상태를 관리하게 하는 것이다.  
창고 서비스나 주문 처리기는 주문 서비스에 상태 업데이트 요청을 보낼 수 있다.  
이때 주문 마이크로서비스는 해당 주문에 대한 '진실의 원천'이다.  

이 상황에서는 창고 서비스와 주문 처리기의 요청을 단순히 요청으로 보는 것이 정말 중요하다.  
이 시나리오에서 주문 애그리거트와 관련돼 가능한 상태 전환을 관리하는 것은 주문 서비스의 일이다.  

따라서 주문 서비스가 주문 처리기로부터 상태를 주문 접수에서 발송 완료로 전환하라는 요청을 받은 경우 잘못된 전환이라면 해당 요청을 거부할 수 있다.  

```
TIP  

마이크로서비스에서 전송된 요청이 유효하지 않을 경우 하위 마이크로서비스가 거부할 수 있는지 확인하라.
```  

이러한 경우 대안은 요청이 데이터베이스 업데이트와 직접적으로 매핑되는 데이터베이스 CRUD 연산을 둘러싼 래퍼(wrapper)와 비슷하게 주문 서비스를 구현하는 것이다.  
마치 비공개필드와 공개 getter와 setter 메서드를 가진 객체와 유사하다.  
이 마이크로서비스의 행동이 상위 소비자들에게 누출돼(응집도 감소) 다른 여러 서비스를 통해서도 허용된 상태 전환을 관리할 수 있는 세계로 돌아왔다.  

공통 결합의 원인은 잠재적으로 리소스 경합의 원인이 될 수 있다.  
여러 마이크로서비스가 동일한 파일 시스템이나 데이터베이스를 사용할 경우 해당 공유 리소스에 과부화가 걸릴 수 있으며, 공유 자원이 느려지거나 아예 사용할 수 없게 되면 잠재적으로 심각한 문제를 일이킬 수 있다.   

특히 공유 데이터베이스에는 이러한 문제가 쉽게 발생할 수 있는데, 여러 소비자가 공유 데이터베이스에 임의의 쿼리를 실행할 수 있고 결국 매우 다양한 성능 특성이 발생할 수 있기 때문이다.  

따라서 공통 결합은 가끔은 괜찮지만, 그렇지 않은 경우가 많다.  
무해한 경우라도 공유 데이터를 변경할 수 있는 범위가 제한돼 있지만, 코드의 응집력이 부족하다는 것을 의미하는 경우가 많다.  
운영 중 경합 측면에서도 문제를 일으킬 수 있다.  
이러한 이유로 공통 결합을 가장 바람직하지 못한 결합 중 하나로 간주하지만, 상황은 더 나빠질 수 있다.  


## 2.3.4 내용 결합  

내용 결합은 상위 서비스가 하위 서비스의 내부까지 도달해 서비스의 내부 상태를 변경하는 상황을 설명한다.  
이 상황을 가장 빈번하게 발생시키는 것은 다른 마이크로서비스의 데이터베이스에 액세스해 직접 변경하는 외부 서비스다.  

내용 결합과 공통 결합의 미묘한 차이가 있다.  
두 경우 모두 둘 이상의 마이크로서비스가 동일한 데이터 집합을 읽고 쓴다.  
공통 결합에서는 공유된 외부 의존성이 사용되고, 이 의존성은 여러분의 통제하에 있지 않다.  
내용 결합에서는 소유권 경계썬이 명확하지 않아 개발자가 시스템을 변경하기 더 어렵다.  

뮤직코프의 예를 다시 살펴보자.  
시스템의 주문에 대해 허용 가능한 상태 변경을 관리하는 주문 서비스가 있다.  
주문 처리기는 주문 서비스에 요청을 전송해 정확한 상태 변경뿐 아니라 어떤 상태 전환이 허용될지 결정하는 책임도 위임한다.  

반면에 창고 서비스는 가능한 변경 사항인지 확인하는 주문 서비스의 기능을 우회해 주문 데이터가 저장된 테이블을 직접 업데이트 한다.  
우리는 창고 서비스가 유효한 변경 사항만 적용하도록 일관된 로직을 갖고 있길 바랄 뿐이다.  
이것은 잘하면 중복 로직이 되지만, 최악의 경우 창고 서비스의 상태 변경 확인 방식이 주문 서비스의 방식과 다르기 때문에 결과적으로 주문이 매우 이상하고 혼동된 상태가 될 수 있다.  

이 상황에서는 주문 테이블의 내부 데이터 구조가 외부에 노출되는 문제도 있다.  
주문 서비스를 변경한다면, 이제부터 특정 테이블을 변경하는 것을 매우 주의해야 한다.  
이는 심지어 외부 당사자가 이 테이블에 직접 액세스하는 것으로 단정할 수 있다.  

이 문제를 쉽게 해결하려면 창고 서비스가 주문 서비스에 요청을 보내게 하면 된다.  
주문 서비스에서 요청을 조사할 수 있지만 내부적인 세부 정보를 숨길 수 있으므로, 이후 주문 서비스를 훤씬 쉽게 변경할 수 있다.  

마이크로서비스에서 작업할 때는 자유롭게 변경 가능한 부분과 그렇지 못한 부분을 명확하게 분리하는 것이 중요하다.  
분명히 말하건대, 개발자는 서비스가 외부에 노출하는 계약 부분의 기능 변경 시점을 알아야 한다.  

또한 변경할 경우에도 상위 서비스가 중단되지 않도록 해야한다.  
마이크로서비스가 노출하는 계약에 영향을 주지 않는 기능은 무난히 변경할 수 있다.  

공통 결합에서 발생하는 문제가 내용 결합에서도 발생하는 것은 분명하지만, 내용 결합에는 일부 사람들이 병적인 결합으로 부르기에 충분한 문제를 일으키는 골칫거리가 더 있다.  
외부에서 직접 여러분의 데이터베이스에 액세스하도록 허용하면 데이터베이스는 실제로 외부 계약의 일부가 돼 변경 가능한 부분과 변경 불가능한 부분을 쉽게 추론할 수 없게 된다.  

어떤 것을 공유하고 어떤 것을 숨길지 정의하는 기능을 상실했다.  
정보 은닉이란 개념이 사라져버린 셈이다.  
한마디로 말해, 내용 결합은 피하라.  












