# 1.2 마이크로서비스의 핵심 개념

## 1.2.1 독립적 배포성
독립적 배포성(independent deployability)은 다른 마이크로서비스를 배포하지 않고도 마이크로서비스를 변경하고, 배포하고, 사용자에게 릴리스할 수 있다는 개념이다.  

```
TIP  

일반적인 마이크로서비스 개념 중 하나를 선택해야 한다면 바로 이 개념이어야 한다.  
즉, 마이크로서비스의 독립적 배포 개념을 반드시 수용해야 한다.  
다른 어떤 것을 추가로 배포하지 않고도 한 마이크로서비스의 변경 사항을 운영 환경에 배포하고 릴리스하는 습관을 들여라.  
그럼 많은 이점이 따를 것이다.  
```  

독립적 배포를 위해서는 마이크로서비스를 느슨하게 결합(loosely coupled)시켜야 한다.  
즉, 다른 마이크로서비스를 변경하지 않고도 한 서비스를 변경할 수 있어야 한다.  

이는 서비스간에 분명하고, 잘 정의되며, 안정적인 계약이 필요하다는 것을 의미한다.  
몇몇 구현 방법은 이런 노력을 어렵게 만들기도 한다.  
예를들면 데이터베이스 공유는 특히 문제가 된다.  

안정적인 인터페이스를 갖고 느슨하게 결합된 서비스를 요구하는 목소리가 커지면서 마이크로 서비스 경계를 찾는 방법을 가장 먼저 생각하게 됐다.  

## 1.2.2 비즈니스 도메인 중심의 모델링  

도메인 주도 설계와 같은 기술을 사용하면 소프트웨어가 동작하는 실제 도메인을 더 잘 표현하도록 코드를 구성할 수 있다.  
마이크로서비스 아키텍처에서는 동일한 개념을 사용해 서비스 경계를 정의한다.  

비즈니스 도메인을 중심으로 서비스를 모델링함으로써 새로운 기능(feature)을 좀 더 쉽게 출시하고 마이크로서비스를 다양한 방식으로 재결합해 사용자에게 새로운 기능을 제공할 수 있다.  
둘 이상의 마이크로서비스를 변경해야 하는 제품 기능을 출시하려면 비용이 많이 든다.  
각 서비스와(어쩌면 분리된 팀과도)작업을 조율해야 하고 해당 서비스들의 새 버전이 배포되는 순서를 주의깊게 관리해야 한다.  

이는 단일 서비스(또는 모놀리식) 내부에서 동일한 변경을 수행하는 것보다 훨씬 더 많은 작업이 필요하다.  
따라서 가능한 한 서비스 간 변경을 적게 수행할 수 있는 방법을 수행한다.  

3계층 아키텍처로 대표되는 계층형 아키텍처를 자주 볼 수 있다.  
| 3계층         | 아키텍처               |
| ------------- | ---------------------- |
| 프론트엔드 팀 | 웹 UI(프레젠테이션)    |
| 백엔드 팀     | 백엔드 (비즈니스 로직) |
| DBA           | 데이터베이스 (데이터)  |  

아키텍처의 각 계층은 관련된 기술적 기능을 기반으로 하는 각 서비스 경꼐를 포함해 서로 다른 서비스 경계를 나타낸다.  
이 예에서 프레젠테이션 계층만 변경해야 한다면 상당히 효율적일 것이다.  
하지만 경험적으로 이 유형의 아키텍처에서 기능 변경은 대개 여러 계층에 걸쳐 나타나 프레젠테이션, 애플리케이션, 데이터 계층의 변경이 필요하다.  

서비스를 비즈니스 기능 단위로(수평이 아닌 수직으로) 처음부터 끝까지 한 조각으로 만들면, 비즈니스 기능을 최대한 효율적으로 변경하도록 아키텍처를 배치할 수 있다.  
우리는 마이크로서비스에서 기술적 기능의 높은 응집력보다 비즈니스 기능의 높은 응집력을 더 우선시하기로 결정했다.   

## 1.2.3 자기 상태 소유

마이크로서비스가 공유 데이터베이스 사용을 피해야 한다는 생각은 많은 사람을 힘들게 한다.  
한 마이크로서비스가 다른 마이크로서비스가 소유한 데이터에 액세스하려면 두 번째 마이크로서비스에 데이터를 요청해야 한다.  

이는 마이크로서비스에 어떤 데이터를 공유하고 감출지 결정하는 능력을 제공하므로 자유롭게 변경할 수 있는 기능(내부 기능)과 거의 변경하지 않는 기능(소비자가 사용하는 외부 계약)을 명확히 분리할 수 있게 해준다.  

독립적 배포성을 실현하려면 마이크로서비스에 대한 하위 호환성이 없는 변경을 제한해야 한다.  
만약 업스트림 소비자와의 호환성을 깨뜨리면 소비자들에게도 변경을 강요할 것이다.  
마이크로 서비스에 대한 내부 구현 상세와 외부 계약을 명확하게 구분하면 하위 호환성이 없는 변경을 줄이는 데 도움이 된다.  

마이크로서비스에서 내부 상태를 감추는 것은 객체 지향 프로그래밍의 캡슐화와 유사하다.  
객체 지향 시스템에서 데이터 캡슐화는 정보 은닉의 실제 예다.  

```
TIP  

정말 필요한 경우가 아니라면 데이터베이스를 공유하지 말라.  
그리고 공유를 회피하기 위해 할 수 있는 모든 것을 수행하라.  
데이터베이스 공유는 독립적 배포성을 달성하는 데 가장 나쁜 것 중 하나이다.  

```

서비스를 적절한 경우에 사용자 인터페이스(UI), 비즈니스 로직, 데이터를 캡슐화하는 비즈니스 기능 단위 조각으로 간주하려 한다.  
비즈니스와 관련된 기능을 변경하는 노력을 줄이고 싶기 때문이다.  

이러한 방식으로 데이터와 동작을 캡슐화하면 비즈니스 기능에 대한 높은 응집력을 얻을 수 있다.  

## 1.2.4 크기

"마이크로서비스는 얼마나 커야 할까요?"  

마이크로서비스 관점에서 '크기'에 가장 가까운 의미는 "마이크로서비스의 목적은 가능한 한 작은 인터페이스를 갖는 것" 이라는 표현에서 짐작해볼 수 있다.  
이는 다시 정보 은닉의 개념과 연결되지만, 초기에는 없었던 '마이크로서비스'라는 용어의 의미를 찾으려는 시도를 나타낸다.  

크기에 대한 걱정은 접어두고 두 가지 핵심사항에 집중하는 것이 중요하다.  

첫째, 얼마나 많은 마이크로서비스를 처리할 수 있는가?  
서비스가 많을수록 시스템의 복잡성이 증가하고, 이에 대처하려면 새로운 기술을 배워야 한다.(아마 그 기술을 채택해야 할 것이다.)  
마이크로서비스로의 전환은 복잡성을 유발하는 근원이되며 이로 인해 발생할 수 있는 모든 문제를 야기한다.  

둘째, 모든 것이 끔찍하게 결합돼 엉망인 상황을 피하면서 마이크로서비스 경계를 최대한 활용하려면 어떻게 경계를 정의해야 하는가?  
이러한 주제는 마이크로서비스로 향하는 여정을 시작할 때 집중해야 하는 훨씬 더 중요한 것들이다.  

## 1.2.5 유연성

제임스 루이스의 또 다른 인용구인 "마이크로서비스는 선택권을 제공한다"라는 말을 생각해보자.  
루이스는 이 말에 신중했다. 마이크로서비스는 비용이 들기 때문에 그 비용이 선택하려는 옵션의 가치에 견줘 적당한지 따져봐야 한다.  
그 결과로 얻는 유연성은 조직성, 기술성, 규모, 견고함 등 여러 측면에서 놀라울 정도로 매력적일 수 있다.  

마이크로서비스의 채택은 "스위치를 켜는 것"이 아니라 "다이얼을 돌리는 것"과 같다고 생각해야 한다.  
다이얼을 높은 쪽으로 돌리고 더 많은 마이크로서비스를 사용할수록 유연성은 높아진다.  

하지만 그만큼 고충도 늘어난다.  
이러한 이유로 필자는 점진적인 마이크로서비스 채택을 강력히 지지한다.  
다이얼을 조금씩 돌려 소리를 키우듯, 점진적으로 적용하면 수행 영향도를 더 잘 판단하고 필요한 경우 중지할 수 있다.  

## 1.2.6 아키텍처와 조직의 정렬

온라인으로 CD를 판매하는 전자상거래 회사인 뮤직코프는 간단한 3계층 아키텍처를 사용한다.  
우리는 뮤직코프를 21세기 방식에 맞추기로 결정했으며, 그 일환으로 기존 시스템 아키텍처를 평가했다.  

기존 아키텍처는 웹 기반 UI, 모놀리식 백엔드 형태의 비즈니스 로직, 전통적 데이터베이스의 데이터 저장소로 구성돼 있으며, 일반적으로 이러한 계층은 각각 다른 팀에서 소유권을 갖는다.  
이 책에서는 뮤직코프가 겪어온 갖가지 고난을 다룰 것이다.  

고객이 좋아하는 음악 장르르 지정할 수 있는 기능에 대해 간단한 업데이트를 원한다.  
예를 들면 고객이 좋아하는 음악 장르를 지정할 수 있도록 하고 싶다.  

이 업데이트에서는 장르 선택 UI를 표시하도록 UI를 변경하고, 장르를 UI에 표시하고 값을 변경할 수 있도록 백엔드 서비스를 변경하며, 데이터베이스가 이 변경을 수용하는 작업이 필요하다.  
이러한 변경사항은 수직 방향으로 각 팀에서 관리되고 올바른 순서로 배포되어야 한다.  

지금 이 아키텍처(모놀리식 3계층)는 나쁘지 않다.  
모든 아키텍처는 결국 일련의 목표를 중심으로 최적화된다.  

하지만 유명한 콘웨이의 법칙은 다음과 같이 명시한다.  
`시스템을 설계하는 조직은 ~ 이러한 조직의 커뮤니케이션 구조를 본떠 설계하도록 제한된다.`  

이 아키텍처는 콘웨이의 법칙이 실제로 적용되는 좋은 예가 될 수 있다.  
과거에 IT조직이 사람들을 그룹화하는 기본 방법은 핵심 역량 측면에 기반했다.  

예를 들면, 데이터베이스 관리자끼리 한 팀에 있었고, 자바 개발자끼리 한 팀이 됐다.  
또한 프론트엔드 개발자로 구성된 별도의 팀도 있었다.  
우리는 핵심 역량을 기반으로 사람들을 그룹화하므로 이러한 팀들에 맞춰진 IT 자산을 만들어냈다. (3계층 모놀리식 아키텍처)  

이 현상은 이 아키텍처가 널리 일반화된 이유를 설명한다.  
이 아키텍처가 나쁜 것이 아니라 일련의 힘, 즉 친숙함을 중심으로 사람들을 그룹화하는 전통적인 방식과 같은 힘에 최적화된 것뿐이다.  

하지만 이제 그 힘이 달라졌다.  
소프트웨어에 대한 우리의 바람이 바뀌었다.  
이제 핸드오프와 사일로를 줄이기 위해 사람들은 다양한 기술을 갖춘 팀으로 묶는다.  
또한 그 어느 때보다 훨씬 더 빨리 소프트웨어를 출시하길 원한다.  
이런 변화는 팀을 구성하는 방식을 다양하게 선택할 수 있도록 했으며, 결국 시스템을 분해하는 방식으로 팀을 구성할 수 있게 됐다.  
  
시스템에 대해 요청받는 변경 사항 대부분은 비즈니스 기능의 변경과 관련이 있다.  
그러나 3계층 모놀리식 아키텍처의 비즈니스 기능은 실제로 3계층에 모두 분산돼 있어 기능 변경이 계층을 넘어갈 가능성이 높다.  

관련 기술의 응집력은 높지만 비즈니스 기능의 응집력이 낮은 아키텍처 이다.  
변경을 더 쉽게 만들고 싶다면, 기술보다는 비즈니스 기능의 응집력을 선택해 코드를 그룹화하는 방법을 바꿔야 한다.  
각 서비스는 3계층의 조합을 포함하거나 포함하지 않을 수 있지만, 특정 서비스의 구현과 관련된 문제다.  

이 아키텍처를 MSA와 비교해보자.  
수평적으로 계층화된 아키텍처와 조직이 아니라 수직적 비즈니스 라인을 따라 조직과 아키텍처를 세분화한다.  
여기에서 고객 프로파일 측면의 변경을 모두 책임지는 전담 팀을 볼 수 있다.  
`따라서 이 예(고객 프로파일)에서 변경 범위는 한 팀으로 제한된다.`

구현 측면에서는 고객이 자기 정보를 업데이트하는 UI를 노출하는, 하나의 마이크로서비스(프로파일 팀이 소유한)가 될 수 있으며, 고객의 상태도 이 서비스에 저장된다.  
선호 장르의 선택은 지정된 고객과 연관되므로 이 변경 사항은 훨씬 더 국부적이다.  

이러한 상황에서 고객 마이크로서비스는 3계층으로 된 얇은 슬라이스 부분을 캡슐화한다.  
비즈니스 도메인은 시스템 아키텍처를 주도하는 핵심 원동력이 돼 변경하기 쉽게 하고 팀을 조직 내 비즈니스 분야에 더 수월하게 맞추도록 할 것이다.  




