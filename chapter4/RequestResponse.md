# 4.7 요청 및 응답 통신

요청 및 응답을 사용하면 마이크로서비스는 다운스트림 서비스에 작업 요청을 보내고 요청에 대한 결과를 받길 기대한다.  
이러한 상호작용은 동기식 볼로킹 호출을 통해 수행되거나 비동기식 논블로킹 방식으로 구현될 수 있다.  

차트 마이크로서비스는 다양한 장르의 베스트셀러 CD를 대조해 일부 CD의 현재 재고 수준을 물어보는 요청을 재고 서비스에 전송한다.  

이처럼 다른 마이크로서비스에서 데이터를 검색하는 것은 요청 및 응답 호출의 일반적인 사용 사례다.  
하지만 가끔은 작업이 완료됐는지 확인해야 한다.  

창고 마이크로서비스는 재고를 예약하라는 주문처리기의 요청을 받는다.  
주문 처리기는 결제를 계속하기 전에 재고가 성공적으로 예약됐음을 알기만 하면 된다.  
재고를 예약할 수 없다면 결제가 취소될 수 있다.  
특정 순서로 호출을 완료해야 하는 이와 같은 상황에서는 요청 및 응답 호출을 사용하는 것이 일반적이다.  

## 4.7.1 구현 : 동기 대 비동기

이와 같은 요청 및 응답 호출은 동기식 블로킹 방식이나 비동기식 논블로킹 방식으로 구현할 수 있다.  

동기식 호출을 사용하면 일반적으로 다운스트림 마이크로서비스와 네트워크 커넥션이 생성되며 이 커넥션을 따라 전송된다.  
업스트림 마이크로서비스가 응답할 때까지 대기하는 동안 커넥션은 열린 상태로 유지된다.  
이 경우 응답하는 마이크로서비스는 요청하는 마이크로서비스에 대해 전혀 알 필요가 없다.  
단지 인바운드 커넥션을 통해 다시 돌려보내는 것 뿐이다.  
따라서 업스트림 또는 다운스트림 마이크로서비스 인스턴스가 종료돼 해당 커넥션이 끊어지면 문제가 발생할 수 있다.  

비동기식 요청 및 응답 방식을 사용하면 덜 간단하다.  
재고 예약과 관련된 프로세스를 다시 살펴보자.  
메시지가 주문처리기에서 창고 마이크로서비스로 바로 이동하는 대신 큐에 보관된다.  
창고 서비스는 가용한 상황에서 이 큐의 메시지를 사용한다.  
요청을 읽고 관련 재고 예약 작업을 수행한 다음, 주문 처리기가 읽고 있는 큐로 응답을 다시 보낸다.  
또한 응답을 어디로 라우팅할지도 알아야 한다.  

이 예에서 창고 서비스는 이 응답을 주문처리기가 사용하는 다른 큐를 통해 다시 전송한다.  
따라서 비동기식 논블로킹으로 상호작용할 때 요청을 수신하는 마이크로서비스는 응답을 어디로 라우팅하는지 암묵적으로 알고 있거나 어디로 응답을 보내야 할지를 알아야 한다.  
큐를 사용할 때 처리 대기 중인 큐에 여러 요청을 버퍼링할 수 있다는 추가적인 이점이 있으며 요청을 충분히 빠르게 처리하지 못하는 상황에서 도움이 된다.  
마이크로서비스는 너무 많은 호출에 압도되지 않고 준비가되면 다음 요청을 소비할 수 있다.  
물론 많은 부분이 이러한 요청을 흡수하는 큐에 좌우된다.  

마이크로서비스가 이와같은 방식으로 응답을 수신하면 원래 요청과 응답을 연결 지어야 할 때가 있다.  
긴 시간이 경과했을지도 모르고 사용 중인 프로토콜의 특성에 따라 응답이 요청을 보낸 동일 마이크로서비스의 인스턴스로 되돌아오지 않을 수 있으므로 이 연결은 여려운 일이다.  
주문 과정의 일부로 재고를 예약하는 예에서 '재고 예약됨'응답을 해당 주문과 연결하는 방법을 알아야 그 주문을 계속 처리할 수 있다.  

이를 쉽게 처리하는 방법은 원래 요청과 관련된 모든 상태를 데이터베이스에 저장하고 응답이 올 때 수신한 인스턴스가 관련된 상태를 다시 로드해서 적절히 동작할 수 있게 하는 것이다.  

마지막으로, 요청 및 응답 상호작용 형태에서는 절대 발생하지 않을 일을 기다리면서 블로킹되는 문제를 피하고자 일종의 타임아웃 처리가 필요하다.  
이 타임아웃 기능은 구현 기술에 따라 구현 방법이 다르지만 필수적이다.  


## 4.7.2 적용 대상

요청 및 응답 호출은 추가 처리가 일어나기 전에 요청 결과를 확인해야 하는 모든 상황에 적합하다.  
또한 호출이 되지 않아서 재시도와 같은 일종의 보상 조치를 수행 가능한 마이크로서비스 환경에서도 매우 적합하다.  
어느 쪽이든 상황에 맞는다면 요청 및 응답이 합당한 방식이다.  

남은 유일한 문제는 앞서 설명한 것과 동일한 장단점이 있을 때 동기식 구현과 비동기식 구현 중 어느 것을 선택할지 결정하는 것이다.  





