# 4.1 프로세스 내부에서 프로세스 사이로

네트워크를 통한 두 프로세스 사이의 호출은 한 프로세스 내부의 호출과 매우 다르다.  
어떤 면에서는 그 차이를 무시할 수 있다.  

예를들어 한 객체가 다른 객체에 메서드 호출을 한다고 생각하고 이 상호작용을 네트워크를 통해 통신하는 2개의 마이크로서비스에 매핑한다고 생각하면 쉽다.  
하지만 마이크로서비스가 단순한 객체가 아니라는 사실을 제쳐두더라도 이러한 생각은 많은 문제를 일으킬 수 있다.  


## 4.1.1 성능

프로세스 내 호출의 성능은 프로세스 간 호출의 성능과 기본적으로 차이가 있다.  
프로세스 내 호출을 할 때, 기본 컴파일러와 런타임은 호출의 영향을 줄이려고 마치 처음에 호출이 없었던 것처럼 전체 호스트 최적화를 수행할 수 있다.  


하지만 프로세스 간 호출에서는 이러한 최적화가 불가능하며, 패킷을 전송해야 한다.  
프로세스 간 호출의 오버헤드는 프로세스 내 호출의 오버헤드에 비해 클 것으로 예상된다.  
프로세스 간 호출의 오버헤드는 확실히 측정할 수 있는데, 예를들면 데이터 센터 안에서 단일 패킷이 왕복하는 데 걸리는 시간을 밀리초 단위로 측정할 수 있지만 메서드 호출의 오버헤드는 걱정하지 않아도 될 만큼 작기 떄문이다.  

이 점은 API를 다시 생각하도록 할 때가 많다.  
프로세스 내부에서 적합한 API가 프로세스 간 상황에서는 적합하지 않을 수 있다.  
프로세스 내부의 API 경계 사이에서는 걱정 없이 1,000번의 호출을 할 수 있다.  
두 마이크로서비스 사이에서도 1,000번의 네트워크 호출을 하는 게 좋을까? 아마도 그렇지 않을 것이다.  

메서드에 매개변수를 전달할 때 보통 전달할 데이터 구조체는 이동되지 않는다.  
대신 메모리 위치에 대한 포인터를 전달할 가능성이 높다.  
객체나 데이터 구조를 다른 메서드에 전달할 때 데이터를 복사하려고 더 많은 메모리를 할당할 필요는 없다.  

반면에 네트워크를 통해 마이크로서비스 간 호출을 할 때 데이터는 전송되고 다른 쪽 끝에서 역직렬화돼야 한다.  
따라서 프로세스 간에 전송되는 페이로드의 크기에 대해 더 주의를 기울여야 한다.  
프로세스 내부에서 전달되는 데이터 구조의 크기를 마지막으로 신경 썼던 저은 언제였나?  
실제로 그다지 알 필요가 없었을 것이다.  

하지만 이제는 알아야 한다.  
송수신 데이터 양을 줄이거나(정보 은닉을 생각한다면 나쁜 것은 아니다.), 더 효율적인 직렬화 매커니즘을 선택하거나 데이터를 파일 시스템으로 내려 해당 파일 위치에 대한 참조 정보를 대신 전달할 수 있기 때문이다.  

이러한 차이점으로 인해 바로 문제가 발생하지는 않지만 확실히 알고 있어야 한다.  
네트워크 호출까지 수반한다는 사실을 개발자에게 숨기려는 시도를 지금껏 많이 봤다.  
세부 사항을 숨기고자 추상화하려는 우리의 바람은 더 많은 일을 더 효율적으로 수행하게 만들지만, 때로는 지나치게 감춰버리는 추상화를 초래한다.  
개발자는 네트워크 호출이 수반되는 작업을 수행하고 있는지 알아야 한다.  
그렇지 않으면, 코드를 작성하는 개발자에게 감춰진 서비스 간의 비정상적 상호작용으로 성능에 심각한 영향을 미치는 병목 현상이 발생하더라도 놀라지 않아야 한다.  

## 4.1.2 인터페이스 변경  

프로세스 내부의 인터페이스 변경을 고려하면 변경 사항을 롤아웃(출시) 하는 것은 간단하다.  
인터페이스를 구현하는 코드와 인터페이스를 호출하는 코드 모두 같은 프로세스에 함께 패키징 된다.  

실제로 리팩터링 기능이 있는 IDE를 사용해 메서드 정의를 변경하면, 종종 IDE는 이 변경이 메서드 를 호출하는 부분을 자동으로 리팩터링한다.  
이러한 변경을 출시하는 것은 원자적 방식으로 수행되는데, 인터페이스와 양쪽이 하나의 프로세스로 패키징되기 때문이다.  

하지만 마이크로서비스 간의 통신에서 인터페이스를 노출하는 마이크로서비스와 해당 인터페이스를 사용하는 소비자 마이크로서비스는 개별적으로 배포 가능한 마이크로서비스이다.  
마이크로서비스 인터페이스에 하위 호환성을 깨뜨리는 변경을 할 때는 둘 다 새 인터페이스를 사용하도록 업데이트하기 위해 소비자와 함께 락스텝 배포를 하거나, 새로운 마이크로서비스 계약의 출시를 단계적으로 수행할 방법을 찾아야 한다.  

## 4.1.3 에러처리


 


