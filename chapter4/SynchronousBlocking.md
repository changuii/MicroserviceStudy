# 4.4 동기식 블로킹 (패턴)

동기식 블로킹 호출을 사용하면, 마이크로서비스가 일종의 호출을 다운스트림 프로세스(아마도 다른 마이크로 서비스)에 보내고 호출이 완료돼 응답이 수신될 때까지 대기한다.  
주문처리기는 고객 계정에 포인트를 추가해야 한다는 것을 알리려고 멤버십 마이크로서비스에 호출을 보낸다.  

일반적으로 동기식 블로킹 호출은 다운스트림 프로세스의 응답을 기다리는 호출이다.  
대기하는 이유는 호출 결과가 이후 연산에 필요하거나 호출이 제대로 작동했는지 확인하고 그렇지 않다면 재시도 등을 수행하려 하기 때문일 수 있다.  

곧 살펴보겠지만, 결과적으로 필자가 본 사실상 모든 동기식 볼로킹 호출은 요청 및 응답 호출로 구성된다.  


## 4.4.1 장점  

동기식 블로킹 호출에는 간단하고 친숙한 무언가가 있다.  
우리 대부분은 기본적으로 동기 방식의 프로그래밍을 배웠다.  

프로세스 간 호출을 사용했던 대부분의 상황에서는 동기식 블로킹 방식으로 수행했을 것이다.  

단일 프로세스의 모놀리스와 같이 덜 분산된 아키텍처에서 전환할 때 새로운 일이 벌어진다면 익숙한 아이디어를 고수하는 것이 합리적이다.  

## 4.4.2 단점

동기식 호출의 주요 문제점은 고유한 시간적 결합에 있다.  
주문 처리기가 멤버십을 호출할 때 호출이 작동하려면 멤버십 마이크로서비스에 연결할 수 있어야 한다.  
만약 멤버십 마이크로서비스가 가용하지 않으면 호출은 실패하고 주문 처리기는 수행할 보상 작업의 종류를 결정해야 한다.  
보상 작업에는 즉각적인 재시도, 나중에 재시도하기 위한 호출 버퍼링 또는 아예 포기하는 것이 포함될 수 있다.  

이 결합은 양방향이다.  
이러한 통합 방식을 사용하면 일바적으로 응답은 동일한 인바운드 네트워크 연결을 통해 업스트림 마이크로서비스에 전송된다.  
따라서 멤버십 마이크로서비스는 다시 주문 처리기에 응답을 보내려고 하지만, 업스트림 인스턴스가 바로 뒤에 종료됐다면 응답은 손실된다.  
여기서 시간적 결합은 단지 두 마이크로서비스 사이에 생기는 것이 아니라 이 마이크로서비스들의 특정 두 인스턴스에 발생한다.  

호출 발신자가 블로킹돼 있고 다운스트림 마이크로서비스의 응답을 기다리고 있을 때 다운스트림 마이크로서비스가 늦게 응답하거나 혹은 네트워크 지연 이슈가 있다면 호출 발신자는 응답을 기다리며 오랜 시간 동안 블로킹될 것이다.  
만약 멤버십 마이크로서비스가 상당한 부하를 받고 있고 요청에 늦게 응답하는 경우라면 주문 처리기도 느리게 응답하게 된다.  

따라서 동기식 호출을 사용하면 비동기식 호출을 사용할 때보다 시스템이 다운 스트림 장애로 인한 연쇄적인 문제에 더욱 취약해진다.  

## 4.4.3 적용 대상

간단한 마이크로서비스 아키텍처라면 동기식 블로킹 호출을 사용하는데 큰 문제가 없으며, 많은 사람에게 익숙하면 분산 시스템을 다룰 때 유리하다.  

필자의 경우, 이러한 호출 유형은 호출 체인이 더 많아질 때 문제가 되기 시작한다.  
예를 들어 결제에 사기 가능성이 있는 활동이 있는지 확인하는 뮤직코프의 처리 흐름에서 주문 처리기는 지불하기 위해 결제 서비스를 호출한다.  
결제 서비스는 결제 허용 여부를 이상 거래 탐지 마이크로서비스에 확인하려고 하며, 이상거래 탐지 마이크로서비스는 고객 마이크로서비스에서 정보를 가져와야 한다.  

호출이 모두 동기식이고 블로킹되면 여러 문제에 직면한다.  
이러한 종류의 긴 체인이 상당한 리소스 경합을 일으킬 수 있다는 사실은 차지하더라도, 관련된 4개의 마이크로서비스 중 하나 또는 이들 간의 네트워크 호출에 문제가 발생하면 전체 작업이 실패할 수 있다.  

내부에서는 주문 처리기가 결제 서비수로부터 응답을 기다리며 네트워크 커넥션을 열어두고 있다.  
결제 서비스는 또한 이상거래 탐지 서비스 등의 응답을 기다린다.  
열린 상태를 유지해야 하는 커넥션이 많으면 실행 중인 시스템에 영향을 줄 수 있다.  
즉, 사용 가능한 커넥션이 부족하거나 결과적으로 네트워크 정체가 증가하는 문제가 발생할 가능성이 훨씬 더 커진다.  

이와 같은 상황을 개선하기 위해 먼저 마이크로서비스 간의 상호작용을 재검토할 수 있다.  
예를 들어 주요 구매 흐름에서 이상거래 감지 기능을 들어내 백그라운드에서 실행하도록 할 수 있다.  
특정 고객의 문제가 발견되면 적절히 기록하고, 이는 결제 프로세스 초기에 확인될 수 있다.  
사실상 이는 작업의 일부를 병렬로 수행하고 있음을 나타낸다.  

우리는 호출 체인의 길이를 줄여 작업의 전반적인 지연 시간이 개선되는 것을 확인할 것이다.  
구매 흐름의 중요 경로에서는 마이크로서비스 하나를 제거해 중요한 작업에 대해 걱정해야 할 의존성을 줄일 수 있다.  

물론 워크플로를 변경하지 않고도 블로킹 호출을 논블로킹 상호작용 방식으로 교체할 수도 있다.  



