# 4.8 이벤트 기반 통신

이벤트 기반 통신은 요청 및 응답 호출에 비하면 꽤 특이해 보인다.  
마이크로서비스가 다른 마이크로서비스에 작업을 요청하는 대신에 마이크로서비스가 다른 마이크로서비스에 수신 여부가 보장되지 않는 이벤트를 발행한다.  
이 방식은 이벤트 리스너가 자체 실행 스레드에서 실행되기 때문에 본질적으로 비동기식 상호작용이다.  

이벤트는 발생한 일에 대한 진술(statement)이다.  
이벤트를 발행하는 마이크로서비스의 세계 내부에서 발생한 일이 거의 언제나 대부분이다.  
이벤트를 발행하는 마이크로서비스는 이벤트를 사용하려는 다른 마이크로서비스가 존재한다는 사실조차 인식하지 못할 수 있다.  
필요할 때 이벤트를 발행하면 그 책임을 다한 것이다.  

주문 포장 프로세스와 관련된 이벤트를 발행하는 창고 서비스를 보여준다.  
이 이벤트를 통지 및 재고 라는 두 마이크로서비스가 수신하고 적절히 반응한다.  
통지 마이크로서비스는 고객에게 주문 상태 변경을 알이는 이메일을 보내고 재고 마이크로서비스는 품목이 고객의 주문으로 포장될 때 재고 수준을 업데이트할 수 있다.  

창고 서비스는 이해당사자가 적절히 반응할 것이라는 가정하에 이벤트를 브로드캐스트할뿐이다.  
이벤트의 수신자가 누구인지 알지 못하기 때문에 일반적으로 이벤트 기반 상호작용이 훨씬 더 느슨하게 결합된다.  
또한 이것을 요청 및 응답 호출과 비교할 때는 책임의 역전 현상을 이해하는데 시간이 걸릴 수 있다.  
요청 및 응답을 사용하면 창고 서비스가 적절한 시기에 통지 마이크로서비스에 이메일을 보내도록 지시할 것으로 예상할 수 있다.  
이러한 모델에서 창고 서비스는 고객 알림이 필요한 이벤트를 알고 있어야 한다.  
대신 이벤트 기반 상호작용을 사용하면 해당 책임을 통지 마이크로서비스에 떠넘길 수 있다.  

이벤트의 숨은 의미는 요청과 반대되는 것으로 간주될 수 있다.  
즉, 이벤트 발행자는 무엇을 할지 결정하는 것을 수신자에게 맡기고 있다.  
요청 및 응답을 사용하면 요청을 보내는 마이크로서비스가 무엇을 해야하는지 알고 다음에 발생해야 한다고 여기는 것을 다른 마이크로서비스에 전달한다.  
물론 이것은 요청 및 응답 방식에서 요청자가 다운스트림 수신자가 수행할 수 잇는 작업에 대한 지식이 있어야 함을 의미하며, 더 높은 수준의 도메인 결합을 나타낸다.  

이벤트 기반 협업 방식을 사용하면 이벤트 발행자는 다운스트림 마이크로서비스가 무엇을 할 것인지 알 필요가 없으며 실제로 존재조차 알지 못할 수 있다.  
결과적으로 결합이 크게 줄어든다.  

이벤트 기반의 상호작용에서 볼 수 있는 책임의 분배는 더 자율적인 팀을 만들려는 조직에서 볼 수 있는 책임의 분배를 반영한다.  
모든 책임을 중앙에서 담당하기보다는 각 팀에 넘겨 더 자율적인 방식으로 운영하길 원하며, 이 개념은 15장에서 다시 다룰 것이다.  
여기서는 책임을 창고 서비스에서 통지 및 결제 서비스로 넘기고 있다.  
이는 창고와 같은 마이크로서비스의 복잡성을 줄이고 시스템의 '지능'을 보다 고르게 분배할 수 있게 한다.  

## 4.8.1 구현

여기서 고려해야할 두가지 주요한 측면이 있는데, 마이크로서비스가 이벤트를 발행하는 방법과 소비자가 해당 이벤트 발생을 알아내는 방법이다.  

전통적으로 래빗엠큐(RabbitMQ)와 같은 메시지 브로커는 두 문제를 모두 처리하려고 한다.  
생산자는 API를 사용해 이벤트를 브로커에게 발행한다.  
브로커는 구독을 처리해 이벤트가 도착하면 소비자가 알림을 받을 수 있도록 한다.  

이러한 브로커는 예를 들면 이전에 본 메시지를 추적하도록 도와서 소비자의 상태도 처리할 수 있다.  
이와 같은 시스템은 일반적으로 확장성과 회복 탄력성을 갖추도록 설계되지만 '공짜'는 아니다.  
이는 서비스를 개발하고 테스트를 수행하는 데 필요한 또 다른 시스템이므로 개발 과정에서 복잡성을 가중시킨다.  

이 인프라스터럭처를 계속 가동하고 실행하려면 추가적인 머신과 전문 지식이 필요할 수 있다.  
하지만 일단 구축되면 느슨하게 결합된 이벤트 기반의 아키텍처를 궇녀하는 데 매우 효과적인 방법이 된다.  
대체로 필자는 이 방식을 좋아한다.  

하지만 메시지 브로커는 미들웨어의 일부에 불과하므로 주의해야 한다.  
큐는 그 자체로 완벽히 합리적이고 유용하지만, 공급업체는 많은 소프트웨어를 함께 패키징하려는 경향이 있으므로 엔터프라이즈 서비스 버스(ESB)에서 보듯이 점점 더 많은 지능이 미들웨어에 들어갈 수 있다.  
따라서 여러분이 얻으려는 것을 확실히 파악해야 한다.  
미들웨어는 멍청하게, 엔드 포인트는 똑똑하게 유지해야 한다.  

또다른 접근 방식은 이벤트를 전파하는 방법으로 HTTP를 사용하는 것이다.  
아톰은 리소스 피드를 게시하기 위한 시맨틱을 정의하는 REST 호환 명세다.  
이러한 피드를 만들고 사용하는 많은 클라이언트 라이브러리가 있으므로, 고객 서비스가 변경될 때마다 고객 서비스는 피드에 이벤트를 바로 게시할 수 있다.  
소비자들은 단순히 피드를 폴맇ㅇ해 변경 사항을 찾는다.  

한편으로는 기존 아톰 명세와 관련 라이브러리를 재사용할 수 있다는 사실도 유용하며, 우리는 HTTP가 확장성을 매우 잘 처리한다는 점도 알고 있다.  
하지만 이러한 HTTP를 사용하면 지연 측면에서 나쁘며, 소비자가 자신이 받은 메시지를 추적하고 자체 폴링 일정도 관리해야 한다는 사실도 여전히 처리해야 한다.  

필자는 사람들이 적절한 메시지 브로커를 사용해 아톰을 일부 사용 사례에 적용할 수 있도록 점점 더 많은 동작을 구현하는 데 오랜 시간을 소비하는 것을 봤다.  
예를 들어 경쟁 소비자 패턴은 메시지를 두고 경쟁하기 위해 여러 워커 인스턴스를 사용하는 방법을 설명한다.  
이는 독립적인 작업들을 처리하기 위해 워커 수를 늘리는 데 적합하다.  
하지만 필요한 것보다 더 많은 작업을 할 수 있으므로 두 명 이상의 워커가 동일한 메시지를 보는 경우는 피해야 하는데, 메시지 브로커를 사용하면 표준 큐가 이를 처리한다.  
아톰을 사용하면, 이제 모든 워커 간에 공유되는 상태를 관리해 중복 잡업을 줄이도록 해야한다.  

우수하고 탄련적인 사용 가능한 메시지 브로커가 이미 있다면, 이를 재사용해 이벤트 게시 및 구독을 처리하는 것이 좋다.  
아직 없다면 아톰을 살펴보길 바란다.  
하지만 매몰 비용 오류는 유의하자.  
메시지 브로커가 제공하는 지원을 점점 더 많이 원하게 된다면 어느 순간 방식을 바꿔야 할 수 있다.  

이러한 비동기식 프로토콜을 통해 실제로 전송하는 것과 관련해 동기식 통신과 동일한 고려 사항이 적용된다.  
현재 JSON을 사용해 요청 및 응답을 인코딩하는 데 만족한다면 계속 사용하라.  

## 4.8.2 이벤트에 포함되는 것  

고객 마이크로서비스에서 새 고객이 시스템에 등록했음을 이해관계자에게 알리는 이벤트가 브로드캐스트되는 것을 보여준다.  
2개의 다운스트림 마이크로서비스인 멤버쉽과 통지는 이 이벤트에 관심이 있다.  
멤버십 마이크로서비스는 포인트 적립을 시작할 수 있도록 신규 고객을 위한 계정을 설정하면서 이벤트 수신에 반응하고, 통지 마이크로서비스는 큰 즐거움을 제공하는 뮤직코프에 온 것을 환영하는 이메일을 신규 등록 고객에게 보낸다.  

요청 방식에서는 마이크로서비스에 무언가 요청하고 요청된 작업을 수행하는데 필요한 정보를 젝오한다.  
이벤트 방식에서는 다른 당사자들이 관심을 가질 만한 사실을 브로드캐스트한다.  
하지만 이벤트를 발생시키는 마이크로서비스는 누가 이벤트를 받는지 알 수 없고 알아서도 안된다.  
그렇다면 다른 당사자가 이벤트에서 어떤 정보를 원하는지는 어떻게 알 수 있을까?  
이벤트 안에는 정확히 무엇이 포함돼야 할까?  

`딱 ID만`  
한 가지 선택지는 이벤트에 새로 등록된 고객의 식별자만 포함하는 것이다.  
멤버십 마이크로서비스는 식별자만 있으면 일치하는 멤버십 계정을 생성할 수 있으므로 더 필요한 정보는 없다.  
하지만 통지 마이크로서비스는 이 유형의 이벤트가 수신될 때 환영 이메일을 보내야 한다는 사실을 알고 있더라도 작업을 수행하려면 최소한 이메일 주소와 개인화된 이메일 전송에 관련된 추가 정보가 필요하다.  

이 정보는 통지 마이크로서비스가 수신받은 이벤트에는 없으므로 고객 마이크로서비스에서 이 정보를 가져올 수 밖에 없다.  

이 방법은 몇 가지 단점이 있다.  
첫째, 통지 마이크로서비스는 이제 고객 마이크로서비스에 대해 알아야 하며 추가적인 도메인 결합이 생겼다.  
2장에서 논의한 것처럼 도메인은 결합 면에서 좀 더 느슨한 편이지만 가능한 한 피하고 싶다.  
통지 마이크로서비스가 수신한 이벤트에 필요한 정보가 모두 포함됐다면 이와 같은 콜백이 필요하지 않으며, 수신한 마이크로서비스의 콜백은 또한 다른 큰 문제로 이어질 수 있다.  
즉, 수신 마이크로서비스가 많은 상황에서는 결과적으로 이벤트를 발산하는 마이크로서비스에 요청이 폭주할 수 있다.  
5개의 서로 다른 마이크로서비스가 모두 동일한 고객 생성 이벤트를 수신하고 모두 추가 정보를 요청해야 하는 경우를 상상해보라.  
필요한 정보를 얻으려면 모두가 즉시 고객 마이크로서비스에 요청을 보내야 한다.  
특정 이벤트에 관심이 있는 마이크로서비스의 수가 증가함에 따라 이러한 호출의 영향은 커질 것이다.  

`매우 자세한 이벤트`  
필자가 선호하는 대안은 API를 통해 공유하는 모든 것을 이벤트에 삽입하는 방식이다.  
통지 마이크로서비스가 특정 고객의 이메일 주소와 이름을 요청해야 한다면, 처음부터 이벤트에 정보를 삽입하는 것이 어떨까?  

통지 서비스는 이제 더 자립적이며 고객 마이크로서비스와 통신하지 않고도 작업을 수행할 수 있다.  
사실 고객 마이크로서비스가 존재하는지 알 필요가 없을지도 모른다.  

더 많은 정보가 포함된 이벤트가 더 느슨한 결합을 가능하게 한다는 사실 외에도 더 많은 정보가 포함된 이벤트는 해당 엔티티에 발생한 일에 대한 기록 덕분에 두 배로 커질 수 있다.  
이는 감사 시스템에 도움을 주거나 특정 시점에 엔티티를 재구성하는 기능을 제공한다.  
즉, 이러한 이벤트를 곧 살펴볼 개념인 이벤트 소싱의 일부분으로 사용할 수 있다.  

확실히 필자가 선호하는 접근 방식이지만, 단점이 없지는 않다.  
첫째, 이벤트와 연관된 데이터가 크면 이벤트 크기를 우려하게 된다.  
최신 메시지 브로커는 메시지 크기에 상당히 관대한 제한을 두고 있다.  
카프카 메시지의 기본 최대 크기는 1MB이고, 이와 같은 큰 메시지에 관한 몇 가지 흥미로운 성능 문제가 예상되더라도 최신 래빗엠큐 릴리스에서는 단일 메시지에 대한 이론적 상한선이 512MB이다.  
하지만 카프카의 메시지 최대 크기인 1MB도 상당량의 데이터를 전송하는 큰 공간이다.  
궁극적으로 이벤트의 크기를 걱정하기 시작하는 곳으로 입문했다면, 일부 정보는 이벤트에 포함되지만 다른 (더 큰) 데이터는 필요할 경우 조회할 수 있는 하이브리드 방식을 권장한다.  

멤버십 서비스는 이메일 주소나 이름을 알 필요가 없음에도 불구하고 이벤트를 통해 전달받는다.  
예를 들어 개인 식별 정보, 결제 카드 세부정보나 이와 유사한 민감한 데이터를 볼 수 있는 마이크로서비스의 범위를 제한하려는 경우 이 문제가 발생할 수 있다.  

이 문제를 해결하는 방법은 두 가지 유형의 이벤트를 보내는 것이다.  
한 이벤트는 PII(개인 식별 정보)를 포함하고 일부 마이크로서비스에서 볼 수 있다.  
다른 이벤트는 PII를 제외하고 더 광범위하게 브로드캐스트할 수 있다.  
이는 서로 다른 이벤트의 가시성을 관리하고 두 이벤트를 발송해야 한다는 측면에서 복잡성이 가중된다.  
마이크로서비스가 첫 번째 종류의 이벤트를 보내고 두 번째 것을 보내기 전에 죽는다면 어떻게될까?  

또 다른 고려사항은 데이터를 이벤트에 포함한다는 것은 외부 세계와 계약의 한 부분이 된다는 사실이다.  
이벤트에서 필드를 제거하면 외부 당사자가 중단될 수 있음을 알아야 한다.  
정보 은닉은 이벤트 기반 협업 방식에서도 중요한 개념이다.  
이벤트에 더 많은 데이터를 추가할 수록 외부 당사자는 이벤트에 대해 더 많은 가정을 해야 한다.  
필자의 일반적 규칙은 요청 및 응답 API를 통해 동일한 데이터를 공유할 수 있다면 이벤트에 정보를 넣어도 괜찮다는 것이다.  

## 4.8.3 적용 대상

이벤트 기반 협업 방식은 정보를 브로드캐스트하길 원하는 상황과 의도를 뒤집는 상황에서 효과가 있다.  
다른 일을 지시하는 모델에서 벗어나 다운스트림 마이크로서비스가 스스로 작업하게 만드는 것은 상당한 매력이 있다.  

다른 요소보다 느슨한 결합에 더 중점을 두는 상황이라면 이벤트 기반 협업은 분명 매력적일 것이다.  

주의할 점은 이러한 협업 방식에 대한 노출이 제한적일 때는 새로운 복잡성의 원인이 되는 경우가 많다는 것이다.  
이와 같은 형태의 통신에 확신이 서지 않는다면 마이크로서비스 아키텍처에서 다양한 상호작용 방식이 혼합될 수 있다는 사실을 상기하라.  
전체를 이벤트 기반 협업 방식으로 할 필요는 없다.  
하나의 이벤트에서 시작해 점차 확장해 나갈 수도 있다.  

개인적으로 필자는 이벤트 기반 협업 방식에 기본적으로 끌린다.  
필자의 뇌는 이러한 통신 유형이 당연한 것처럼 보이도록 스스로 재구성된 것 같다.  
이것이 옳다고 느끼는 것외에는 왜 그런지 설명하기가 까다로울 수 있으므로 이런 말은 도움이 되지 않는다.  
하지만 이는 자신의 경험을 바탕으로 자신이 아는 것에 자연스럽게 끌리게 되는 자신만의 편견일 뿐이다.  
이 형태의 상호작용에 대한 애착은 지나치게 결합된 시스템을 경험했던 이전의 나쁜 기억에서 전적으로 기인했을 가능성이 높다.  

여기서 필자가 아무런 편견 없이 말하고 싶은 것은 요청 및 응답 상호작용을 이벤트 기반의 상호작용으로 바꾸는 팀이 그 역방향으로 바꾸는 팀보다 훨씬 많다는 사실이다.  







